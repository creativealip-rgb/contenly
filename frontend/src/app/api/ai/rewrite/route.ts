import { NextResponse } from 'next/server'
import type { AIRewriteRequest, AIRewriteResponse } from '@/types/ai'

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api/v1'

export async function POST(request: Request) {
    try {
        const body: AIRewriteRequest = await request.json()

        if (!body.content) {
            return NextResponse.json<AIRewriteResponse>(
                { success: false, error: 'Content is required' },
                { status: 400 }
            )
        }

        console.log('üîÑ Frontend: Proxying AI rewrite request to backend...')

        // Prepare headers and forward cookies for authentication
        const headers: HeadersInit = {
            'Content-Type': 'application/json',
        }

        // Forward cookies from the incoming request to backend
        const cookieHeader = request.headers.get('cookie')
        if (cookieHeader) {
            headers['Cookie'] = cookieHeader
        }

        // Add authorization header if present (fallback)
        const authHeader = request.headers.get('authorization')
        if (authHeader) {
            headers['Authorization'] = authHeader
        }

        // Call backend AI generate endpoint
        // Note: Backend DTO expects flat structure, not nested options
        const backendResponse = await fetch(`${API_URL}/ai/generate`, {
            method: 'POST',
            headers,
            body: JSON.stringify({
                originalContent: body.content,
                title: body.title,
                sourceUrl: body.sourceUrl,
                feedItemId: body.feedItemId,
                // Backend expects options as optional nested object without validation decorators
                // So we can send it as is
                options: {
                    tone: body.tone || 'professional',
                    length: body.targetLength === 'shorter' ? 'short' :
                        body.targetLength === 'longer' ? 'long' : 'medium',
                    keywords: [], // Will be generated by AI
                    targetLanguage: 'Indonesian',
                }
            })
        })

        if (!backendResponse.ok) {
            const error = await backendResponse.json()
            throw new Error(error.message || 'Backend AI generation failed')
        }

        const backendData = await backendResponse.json()
        console.log('‚úÖ Frontend: Received response from backend')

        // Format response to match frontend expectations
        return NextResponse.json<AIRewriteResponse>({
            success: true,
            data: {
                title: body.title || 'Rewritten Article',
                content: backendData.content,
                excerpt: backendData.content.substring(0, 150),
                metaDescription: backendData.content.substring(0, 160),
                seoKeywords: [], // Will be generated by AI
                articleId: backendData.articleId
            },
        })

    } catch (error: any) {
        console.error('‚ùå AI Rewrite Error:', error)
        return NextResponse.json<AIRewriteResponse>(
            { success: false, error: error.message || 'Failed to rewrite content' },
            { status: 500 }
        )
    }
}
